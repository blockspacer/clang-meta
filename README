DESCRIPTION
-------------------------

A C++ compiler with added meta-programming features: 
1) static reflection (of Clang AST nodes), 
2) metaparsing, 
3) custom diagnostics, and
4) constexpr containers.


EXAMPLES
-------------------------

Best to just check out the examples folder.  There's a lot of new stuff here.  
It will be worth your time.   This is the real deal, a huge new metaprogramming 
feature set, pretty much ready for prime time.

I've even implemented it so as to trick your IDE into providing support -- 
code completion, etc.  No need to wait a decade.  It's ready now!


ACKNOWLEDGMENTS
-------------------------

This work is based around llvm/clang 7.0.0.  More significantly, this
work is adapted from Andrew Sutton's original reflection/metaclasses repository: 
	https://github.com/asutton/clang.
Many thanks to him for sharing his excellent work; without it these additional 
contributions would not have been possible.


 INSTALLATION (Mac/Unix):
-------------------------

1. Download CMake if necessary.

2. Create a folder to house the source, build, and examples.  We'll call it clang-meta.
	mkdir clang-meta
	
2. Clone this repository into that folder:
	git clone https://github.com/drec357/clang-meta.git clang-meta
	
3. The clang-meta folder should now have our "llvm" and "examples" folders in it.
   In addition, make a "build" folder, and navigate to it:
	cd clang-meta
	mkdir build
	cd build
	
4. Run CMake on the llvm sources:
	cmake ../llvm
	
5. Do the initial build (may take a few hours):
	cmake --build .
  (Don't sweat the various warnings.  I'll try to address them soon.  They don't matter.)
	
6. Build the clang-wreflection target:
	cmake --build . --target clang-wreflection
	
7. Navigate to build/include, make sure a client-reflection-impl.hpp file has been created.  Make note of the path to it.  Also, in build/bin, there should be a clang++ executable/shortcut.  Make note of the absolute path to that -- you will need it shortly to instruct your IDE to use it as your CXX compiler.

8. Open clang-meta/examples/include/client_reflection_impl.hpp file.  It is intended to be a helper shortcut to your root client_reflection_impl.hpp.  Right now it contains a relative path that is probably correct for now.  But it would be best to change that to the absolute path to your clang-meta/build/include/client_reflection_impl.hpp, in case you want to move examples/include around later.

9. Open your IDE -- I highly recommend XCode for Mac users; its code completer works very well for our purposes, whereas e.g. CLion's does not.  You may need to try a few out.

10. Import our "examples" folder into a new project, or set up a new one from scratch; all you need is to #include each of the example files (0_reflection.hpp, 1_metaparsing.hpp etc.).

11. Change the compilers/other IDE settings for this project:
--In XCode: go to Build Settings for the project, then:
  a) FIRST, search for "index", and set "Enable Index-While-Building Functionality" to No.
  b) THEN, search for "dialect", and set your C++ dialect to either C++17 or GNU++17 (for optimal IDE support)
  c) Lastly, click the "+" button, click Add User-Defined Setting, and assign "CXX" to the full path to your new clang++ binary (e.g. /.../clang-meta/build/bin/clang++)
     And I suppose do this again and assign "CC" to e.g. /.../clang-meta/build/bin/clang.
--In CMake-based IDEs like CLion, you must set CMAKE_CXX_COMPILER and CMAKE_C_COMPILER appropriately.  (I don't think you'll
  encoutner the index-search-path issue there; that is an XCode-specific issue.)

12. Then, build the example project.  I recommend going through the examples in order, there is a lot of new stuff here.  As explained in 0_reflection.hpp, you may encounter an unexplained crash now and then -- just rebuild if you do.


Please raise an Issue if you encounter one.  Even better, raise one if you encountered an issue but came up with a solution
to share with others.
Also please raise even aesthetic/naming concerns, those are important to address early on.


DISCUSSION - REFLECTION
-------------------------

There are many C++ reflection proposals floating around.  I believe the way I've done it here is the best.  I have simply automated generation of reflection properties from the public methods/fields of clang AST nodes and helper types, creating a massive reflection library in a matter of minutes.

E.g., if clang::NamespaceDecl has an isAnonymousNamespace() public method, so the user will be able to access a reflexpr(mynamespace)->isAnonymousNamespace() reflection.

More generally, my argument is that the C++ standard should define a minimum compiler AST architecture that all compilers must use; this would be the basis of the reflection library.

This has four main benefits over the existing reflection proposals:
1) No parallel code to maintain -- e.g. you don't need to keep up to date an NamespaceDecl::isAnonymousNamespace() member AND some sort of reflectIsAnonymousNamespace() function.

2) Reflection properties can take advantage of the object oriented architecture of the clang AST.  Existing reflection proposals seem to only allow the user to query reflections via external functions or templates -- e.g. 
	
	//CURRENT REFLECTION PROPOSALS:
	meta::decls_of(myclassrefl)
	meta::decls_of<myclassrefl>
	        ^   ^    ^
		       Code completer can only offer loose suggestions at best throughout
	
Whereas my proposal places the object first in the typical way, allowing the IDE to assist in code completion:

	//MY REFLECTION IMPLEM:
	myclassrefl->decls()
		     ^
		     Code completer can make precise suggestions right away
		     
3) Improvements to the compilers' ASTs would be linked inextricably to improvements to the C++ standards, which would benefit all.

4) Reflection implementers needn't answer to complaints about what properties of this or that decl are or are not reflectible.  Any change a user wants, she or he can make by modifying the AST interface and rebuilding clang-wreflection -- and indeed they should.  Interested parties can have discussions about what they want reflected without feeling they are hostage to the reflection implementers, and the implementers can work without having to engage in the hundreds of arguments sure to be required to make such decisions.  The two are decoupled.

Everyone wins with this approach.


DISCUSSION - METAPARSING
-------------------------

The metaparsing feature will, I suspect, have some detractors.  It feels a bit Python-y; a bit out of place in strict typing environment like C++.
This is why, I imagine, other proposals lean toward methods of source code "injection" or modification using cleaner, more C++-like statements:

	// CURRENT INJECTION PROPOSALS:
	myfuncrefl->addVirtual();

instead of 

	// MY METAPARSING IMPLEM:
	QPARSE("virtual ", ...outright textual copying of function signature...);
	
I disagree, for some of the same reasons as above: with the metaparsing solution, there is
1) no parallel code to maintain -- new parse-able keywords etc. are automatically supported, and
2) Implementers like myself needn't answer to questions about what is or is not injectible.

Not to mention that it is dirt-simple to understand, and it seems to me there may be cases that ONLY metaparsing can solve; it really does offer some new capabilities I believe.



I will address further issues here as they arise.  
Please let me know if you run into problems anywhere.

Have fun!

Dave
